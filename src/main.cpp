/* -LICENSE-START-
 ** Copyright (c) 2018 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 **
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "BlackmagicRawAPI.h"

#include <cstdio>
#include <cstdint>
#include <cstring>
#include <cmath>
#include <iostream>
#include <chrono>
#include <atomic>
#include <thread>

#include <turbojpeg.h>

#include "brawshot.h"

#ifdef DEBUG
	#include <cassert>
	#define VERIFY(condition) assert(SUCCEEDED(condition))
#else
	#define VERIFY(condition) condition
#endif

#define	JPEG_QUALITY	95
#define	JPEG_SUBSAMP	TJSAMP_444
#define	JPEG_FLAGS	(TJFLAG_FASTDCT)

static const BlackmagicRawResourceFormat s_resourceFormat = blackmagicRawResourceFormatRGBAU16;
static const char* outputFileName = "output";

static const int s_maxJobsInFlight = 1;
static std::atomic<int> jobsInFlight = {0};

static tjhandle tjinst = nullptr;

void output_image(unsigned int width, unsigned int height, uint8_t* image,
		unsigned long index)
{
	char filename[256];
	sprintf(filename, "%s-%04lu.jpg", outputFileName, index);

	unsigned char* jpeg_buf = NULL;
	unsigned long jpeg_size = 0;

	if(tjCompress2(tjinst, image, width, 0, height, TJPF_BGR, &jpeg_buf,
				&jpeg_size, JPEG_SUBSAMP, JPEG_QUALITY,
				JPEG_FLAGS) < 0) {
		printf("compression error\n");
		exit(1);
	} else {
		FILE* f = fopen(filename, "wb");
		fwrite(jpeg_buf, jpeg_size, 1, f);
		fclose(f);
		tjFree(jpeg_buf);
	}
}

struct UserData {
	VideoProcessor*	processor;
	unsigned long	index;
	bool		add;
	bool		output;

	UserData(VideoProcessor* processor, bool add, bool output)
			: processor(processor), add(add), output(output) {}
	~UserData() {}
};

class CameraCodecCallback : public IBlackmagicRawCallback
{
public:
	explicit CameraCodecCallback() = default;
	virtual ~CameraCodecCallback() = default;

	virtual void ReadComplete(IBlackmagicRawJob* readJob, HRESULT result, IBlackmagicRawFrame* frame) {
		IBlackmagicRawJob* decodeAndProcessJob = nullptr;

		UserData* userData = nullptr;
		VERIFY(readJob->GetUserData((void**)&userData));

		if(result == S_OK) {
			VERIFY(frame->SetResourceFormat(s_resourceFormat));
		}

		if(result == S_OK) {
			result = frame->CreateJobDecodeAndProcessFrame(nullptr, nullptr, &decodeAndProcessJob);
		}

		if(result == S_OK) {
			result = decodeAndProcessJob->SetUserData(userData);
		}

		if(result == S_OK) {
			result = decodeAndProcessJob->Submit();
		}

		if(result != S_OK) {
			if(decodeAndProcessJob) {
				decodeAndProcessJob->Release();
			}
		}

		readJob->Release();
	}

	virtual void ProcessComplete(IBlackmagicRawJob* job, HRESULT result, IBlackmagicRawProcessedImage* processedImage) {
		unsigned int width = 0;
		unsigned int height = 0;
		void* imageData = nullptr;

		if(result == S_OK) {
			result = processedImage->GetWidth(&width);
		}

		if(result == S_OK) {
			result = processedImage->GetHeight(&height);
		}

		if(result == S_OK) {
			result = processedImage->GetResource(&imageData);
		}

		UserData* userData = nullptr;
		VERIFY(job->GetUserData((void**)&userData));

		if(result == S_OK) {
			if(userData->add) {
				userData->processor->add((uint16_t*) imageData);
			} else {
				userData->processor->subtract((uint16_t*) imageData);
			}

			if(userData->output) {
				uint8_t* output = new uint8_t[width * height * 3];
				userData->processor->output(output);

				--jobsInFlight;
				unsigned long index = userData->index;
				output_image(width, height, output, index);
				delete[] output;
			} else {
				--jobsInFlight;
			}
		}

		delete userData;

		job->Release();
	}

	virtual void DecodeComplete(IBlackmagicRawJob*, HRESULT) {}
	virtual void TrimProgress(IBlackmagicRawJob*, float) {}
	virtual void TrimComplete(IBlackmagicRawJob*, HRESULT) {}
	virtual void SidecarMetadataParseWarning(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void SidecarMetadataParseError(IBlackmagicRawClip*, const char*, uint32_t, const char*) {}
	virtual void PreparePipelineComplete(void*, HRESULT) {}

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID*) {
		return E_NOTIMPL;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef(void) {
		return 0;
	}

	virtual ULONG STDMETHODCALLTYPE Release(void) {
		return 0;
	}
};

HRESULT ProcessClip(IBlackmagicRawClip* clip, const char* lut_filename,
		unsigned int window_size)
{
	HRESULT result;

	long unsigned int frameCount = 0;
	long unsigned int frameIndex = 0;

	unsigned int width = 0;
	unsigned int height = 0;

	result = clip->GetWidth(&width);
	result = clip->GetHeight(&height);

	VideoProcessor processor(width, height, lut_filename);

	result = clip->GetFrameCount(&frameCount);

	unsigned long output_delay = window_size;
	if(output_delay > frameCount) {
		output_delay = frameCount;
	}

	while(frameIndex < frameCount) {
		if(jobsInFlight >= s_maxJobsInFlight) {
			std::this_thread::sleep_for(std::chrono::microseconds(100));
			continue;
		}

		float percent = frameIndex * 100.0 / frameCount;
		printf("\r\x1b[KProcessing frame %lu [%5.1f%%]", frameIndex, percent);
		fflush(stdout);

		bool output = frameIndex >= output_delay - 1;
		if(frameIndex >= output_delay) {
			unsigned long idx = frameIndex - output_delay;
			IBlackmagicRawJob* jobRead = nullptr;
			if(result == S_OK) {
				result = clip->CreateJobReadFrame(idx, &jobRead);
			}

			UserData* userData = nullptr;
			if(result == S_OK) {
				userData = new UserData(&processor, false, false);
				VERIFY(jobRead->SetUserData(userData));
			}

			if(result == S_OK) {
				result = jobRead->Submit();
			}

			if(result != S_OK) {
				if(jobRead != nullptr) {
					jobRead->Release();
				}

				break;
			}

			++jobsInFlight;

			while(jobsInFlight >= s_maxJobsInFlight) {
				std::this_thread::sleep_for(std::chrono::microseconds(100));
			}
		}

		IBlackmagicRawJob* jobRead = nullptr;
		if(result == S_OK) {
			result = clip->CreateJobReadFrame(frameIndex, &jobRead);
		}

		UserData* userData = nullptr;
		if(result == S_OK) {
			userData = new UserData(&processor, true, output);
			if(output) {
				userData->index = frameIndex - output_delay + 1;
			}
			VERIFY(jobRead->SetUserData(userData));
		}

		if(result == S_OK) {
			result = jobRead->Submit();
		}

		if(result != S_OK) {
			if(jobRead != nullptr) {
				jobRead->Release();
			}

			break;
		}

		++jobsInFlight;

		frameIndex++;
	}

	printf("\n");

	printf("Waiting for jobs to finish...\n");

	while(jobsInFlight > 0) {
		std::this_thread::sleep_for(std::chrono::microseconds(50));
	}

	return result;
}

int main(int argc, const char** argv)
{
	const char* self = *argv;
	const char* lut_filename = nullptr;
	const char* clipName = nullptr;
	unsigned int window_size = 100;

	argc--;
	argv++;

	for(; argc; argc--, argv++) {
		if(!strcmp(*argv, "-l") && argc > 1) {
			lut_filename = argv[1];
			argc--;
			argv++;
		} else if(!strcmp(*argv, "-o") && argc > 1) {
			outputFileName = argv[1];
			argc--;
			argv++;
		} else if(!strcmp(*argv, "-i") && argc > 1) {
			clipName = argv[1];
			argc--;
			argv++;
		} else if(!strcmp(*argv, "-w") && argc > 1) {
			int win = atoi(argv[1]);
			if(win < 0) {
				std::cerr << "Invalid window size" << std::endl;
				return 1;
			}
			window_size = (unsigned int) win;
			argc--;
			argv++;
		} else {
			std::cerr << "Usage: " << self << " -i clip.braw [-o image.bmp]" << std::endl;
			return 1;
		}
	}

	if(clipName == nullptr) {
		std::cerr << "Missing clip name" << std::endl;
		return 1;
	}

	tjinst = tjInitCompress();

	HRESULT result = S_OK;

	IBlackmagicRawFactory* factory = nullptr;
	IBlackmagicRaw* codec = nullptr;
	IBlackmagicRawClip* clip = nullptr;

	CameraCodecCallback callback;

	unsigned int width = 0;
	unsigned int height = 0;

	factory = CreateBlackmagicRawFactoryInstanceFromPath("/usr/lib/blackmagic/BlackmagicRAWSDK/Linux/Libraries/");
	if(factory == nullptr) {
		std::cerr << "Failed to create IBlackmagicRawFactory!" << std::endl;
		goto end;
	}

	result = factory->CreateCodec(&codec);
	if(result != S_OK) {
		std::cerr << "Failed to create IBlackmagicRaw!" << std::endl;
		goto end;
	}

	result = codec->OpenClip(clipName, &clip);
	if(result != S_OK) {
		std::cerr << "Failed to open IBlackmagicRawClip!" << std::endl;
		goto end;
	}

	result = codec->SetCallback(&callback);
	if(result != S_OK) {
		std::cerr << "Failed to set IBlackmagicRawCallback!" << std::endl;
		goto end;
	}

	result = clip->GetWidth(&width);
	if(result != S_OK) {
		std::cerr << "Failed to get image width!" << std::endl;
		goto end;
	}

	result = clip->GetHeight(&height);
	if(result != S_OK) {
		std::cerr << "Failed to get image height!" << std::endl;
		goto end;
	}

	ProcessClip(clip, lut_filename, window_size);

	codec->FlushJobs();

end:
	if(clip != nullptr) {
		clip->Release();
	}

	if(codec != nullptr) {
		codec->Release();
	}

	if(factory != nullptr) {
		factory->Release();
	}

	return result;
}
